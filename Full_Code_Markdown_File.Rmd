---
title: "Analysis of Smart Device Usage for Bellabeat Marketing Strategy"
author: "By Dane Tipene"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 2
---
<script>
document.addEventListener("DOMContentLoaded", function() {
  var buttons = document.getElementsByClassName("toggleButton");
  var contents = document.getElementsByClassName("codeContent");

  for (let i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener("click", function() {
      var content = contents[i];
      if (content.style.display === "none") {
        content.style.display = "block";
        this.innerText = "Hide " + this.innerText.substring(5);
      } else {
        content.style.display = "none";
        this.innerText = "Show " + this.innerText.substring(5);
      }
    });
  }
});
</script>


<div style="margin-top: 20px;"></div>

<br><br>

```{r bellabeat_logo, echo=FALSE, out.width='40%', out.height='40%'}
knitr::include_graphics(here::here("bellabeat_logo.png"))
```

[Bellabeat](https://bellabeat.com/), founded by Urska Srsen and Sando Mur, specializes in health-focused smart products designed to inform and inspire women. Since its inception in 2013, Bellabeat has rapidly grown and positioned itself as a leader in tech-driven wellness products for women.
<br><br>

# <span style="color: #FF8967;">Phase 1: Ask</span>

### Business Task

Analyze non-Bellabeat smart device usage data to gain insights that will enhance Bellabeat’s marketing strategy. Apply these insights to a selected Bellabeat product for targeted improvements.


### Key Stakeholders
- Urska Srsen: Bellabeat's cofounder and Chief Creative Officer
- Sando Mur: Bellabeat's cofounder and key member of executive team
- Bellabeat Marketing Team


### Market Insights
According to Fortune Business Insights, as well as studies and statistics from ValuePenguin (April 2022) and RunRepeat (October 2021), the following insights were observed:

- Market Growth: The global fitness tracker market is projected to grow from USD 53.94 billion in 2023 to USD 290.85 billion by 2032, at a CAGR of 21.3%.
- User Engagement: 92% of smartwatch wearers use their devices for health and fitness monitoring, with 88% claiming they helped in achieving fitness goals. Smartwatches hold the largest smart device type market share.
- Application: Running is the most common use, with 42.8% of users globally prioritizing this feature.
- Shipping Volume: 445 million wearable fitness devices were shipped, highlighting strong demand and market potential.
- Pandemic Impact: Fitness tracker shipments and revenue grew over 31% during the COVID-19 pandemic, indicating increased consumer interest in health.
- Gender: Women are nearly 40% more likely to use fitness trackers than men, benefiting female-focused brands like Bellabeat.
- For more detailed insights, you can refer to the full article [here.](https://www.fortunebusinessinsights.com/fitness-tracker-market-103358)
<br><br>
<br><br>

# <span style="color: #FF8967;">Phase 2: Prepare</span>

### Data Source
- Fitabase dataset made available through Kaggle user [Mobius](https://www.kaggle.com/datasets/arashnic/fitbit) and licensed under CC0: Public Domain
- Dataset generated from 33 eligible Fitbit user logs from smart devices
- Acknowledgements - Robert Furger, Julia Brinton, Michael Keating, Alexa Ortiz


### Data Credibility
The data is reliable but dated, originating from 2016 and collected over 31 days from 33 participants.

The small sample size of 33 participants reduces the confidence level of the derived insights. Additionally, the absence of demographic information such as gender, age, and location makes it highly unlikely to determine if the data accurately represents the population. This also hinders the identification of female-specific trends.


### Chosen Tools
I initially examined the datasets in Excel to sort and filter the data. However, the 'Minute' datasets contained millions of rows, making it impractical to manage in Excel. Therefore, I loaded all the data into R Studio for more efficient cleaning and analysis.

- Excel
- R
- R Packages

<button class="toggleButton">Show Package Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r installed_packages, eval=FALSE, results='hide', message=FALSE}
install.packages("tidyverse")
install.packages("lubridate")
install.packages("janitor")
install.packages("readxl")
install.packages("data.table")
```

```{r load_packages, eval=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(janitor)
library(readxl)
library(data.table)
```
</code></pre>
</div>


### Chosen Datasets
- dailyActivity_merged
- dailyCalories_merged
- dailyIntensities_merged
- dailySteps_merged
- heartrate_seconds_merged
- hourlyCalories_merged
- hourlyIntensities_merged
- hourlySteps_merged
- minuteintensitiesNarrow_merged
- minutesSleep_merged
- sleepDay_merged
- weightLogInfo_merged

<button class="toggleButton">Show Loaded CSV Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r loaded_csv_files, eval=TRUE}
daily_activity <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/dailyActivity_merged.csv")
daily_calories <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/dailyCalories_merged.csv")
daily_intensities <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/dailyIntensities_merged.csv")
daily_steps <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/dailySteps_merged.csv")
hourly_calories <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/hourlyCalories_merged.csv")
hourly_intensities <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/hourlyIntensities_merged.csv")
hourly_steps <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/hourlySteps_merged.csv")
minute_sleep <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/minuteSleep_merged.csv")
sleep_day <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/sleepDay_merged.csv")
weight_log <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/weightLogInfo_merged.csv")

```

```{r loaded_separately, eval=TRUE}
# Load separately to avoid crash
heartrate_seconds <- read.csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/heartrate_seconds_merged.csv")
```

```{r loaded_separately2, eval=TRUE}
# Load separately to avoid crash
minute_intensities <- read_csv("mturkfitbit_export_4.12.16-5.12.16/Fitabase Data 4.12.16-5.12.16/minuteIntensitiesNarrow_merged.csv")
```
</code></pre>
</div>
<br><br>

# <span style="color: #FF8967;">Phase 3: Process</span>

## Cleaning Log
#### Inspect and Preview All Datasets

- Inspected Data using 'str()' function
- Searched for matching columns for potential merging, and checked for inconsistencies in column names and formats
- Found "Id", "ActivityDate", and "ActivityHour" columns suitable for merging separate daily and hourly datasets

    
<button class="toggleButton">Show Data Inspection Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r data_inspection, eval=TRUE}
# Look for matching columns, inconsistencies in column names and in column formats
str(daily_activity)
str(daily_calories)
str(daily_intensities)
str(daily_steps)
str(heartrate_seconds)
str(hourly_calories)
str(hourly_intensities)
str(hourly_steps)
str(minute_intensities)
str(minute_sleep)
str(sleep_day)
str(weight_log)
```
</code></pre>
</div>


#### Dataset Transformations

- Cleaned inconsistent column names to match appropriate datasets
- Renamed date/time columns to either "ActivityDate", "ActivityMinutes", or "ActivitySeconds"
- Renamed ‘daily_activity’/“TotalSteps” to “StepTotal” to align with other 'steps' datasets
- Standardized inconsistent date/time formats
- A total of 33 participants were identified, which is 3 more than originally stated in the dataset description.
- Identified 65 missing values in the 'weight_log' dataset and chose not to delete these rows, as it would remove 99% of the data
- Identified and removed 3 duplicates from the 'sleep_day' dataset
- Identified and removed 543 duplicates from the 'minute_sleep' dataset
- Found the 'minute_sleep' dataset to be of no value and excluded it from the analysis
- Merged Daily datasets together
- Merged Hourly datasets together
- Reduced datasets from 12 to 5: two merged datasets ('daily_combined' and 'hourly_combined') and three separate datasets ('minute_intensities', 'heartrate_seconds' and 'weight_log')



<button class="toggleButton">Show Column Transformation Code Details</button>
<br><br>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r column_transformation, eval=TRUE}
# Rename columns to ensure consistency and match 'daily_activity' dataset
colnames(daily_activity)[colnames(daily_activity) == "TotalSteps"] <- "StepTotal"
colnames(daily_calories)[colnames(daily_calories) == "ActivityDay"] <- "ActivityDate"
colnames(daily_intensities)[colnames(daily_intensities) == "ActivityDay"] <- "ActivityDate"
colnames(daily_steps)[colnames(daily_steps) == "ActivityDay"] <- "ActivityDate"
colnames(heartrate_seconds)[colnames(heartrate_seconds) == "Time"] <- "ActivitySeconds"
colnames(heartrate_seconds)[colnames(heartrate_seconds) == "Value"] <- "Bpm"
colnames(sleep_day)[colnames(sleep_day) == "SleepDay"] <- "ActivityDate"
colnames(minute_intensities)[colnames(minute_intensities) == "ActivityMinute"] <- "ActivityMinutes"
colnames(minute_sleep)[colnames(minute_sleep) == "date"] <- "ActivityMinutes"
colnames(weight_log)[colnames(weight_log) == "Date"] <- "ActivityDate"

# Ensure date columns are in the same format
daily_activity$ActivityDate <- as.Date(daily_activity$ActivityDate, format="%m/%d/%Y")
daily_calories$ActivityDate <- as.Date(daily_calories$ActivityDate, format="%m/%d/%Y")
daily_intensities$ActivityDate <- as.Date(daily_intensities$ActivityDate, format="%m/%d/%Y")
daily_steps$ActivityDate <- as.Date(daily_steps$ActivityDate, format="%m/%d/%Y")
heartrate_seconds$ActivitySeconds <- as.POSIXct(heartrate_seconds$ActivitySeconds, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())
hourly_calories$ActivityHour <- as.POSIXct(hourly_calories$ActivityHour, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())
hourly_intensities$ActivityHour <- as.POSIXct(hourly_intensities$ActivityHour, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())
hourly_steps$ActivityHour <- as.POSIXct(hourly_steps$ActivityHour, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())
sleep_day$ActivityDate <- as.Date(sleep_day$ActivityDate, format="%m/%d/%Y")
minute_intensities$ActivityMinutes <- as.POSIXct(minute_intensities$ActivityMinutes, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())
minute_sleep$ActivityMinutes <- as.POSIXct(minute_sleep$ActivityMinutes, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())
weight_log$ActivityDate <- as.POSIXct(weight_log$ActivityDate, format="%m/%d/%Y %I:%M:%S %p", tz=Sys.timezone())

# Confirm changes in final inspection
str(daily_activity)
str(daily_calories)
str(daily_intensities)
str(daily_steps)
str(heartrate_seconds)
str(hourly_calories)
str(hourly_intensities)
str(hourly_steps)
str(minute_intensities)
str(minute_sleep)
str(sleep_day)
str(weight_log)
```
</code></pre>
</div>


<button class="toggleButton">Show Missing Value Code Details</button>
<br><br>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r missing_values, eval=TRUE}
# Identify missing values
# List of datasets
datasets <- list(
  daily_activity = daily_activity,
  daily_calories = daily_calories,
  daily_intensities = daily_intensities,
  daily_steps = daily_steps,
  heartrate_seconds = heartrate_seconds,
  hourly_calories = hourly_calories,
  hourly_intensities = hourly_intensities,
  hourly_steps = hourly_steps,
  minute_intensities = minute_intensities,
  minute_sleep = minute_sleep,
  sleep_day = sleep_day,
  weight_log = weight_log
)

# Check for missing values in each dataset
for (name in names(datasets)) {
  cat("\nChecking for missing values in:", name, "\n")
  print(sapply(datasets[[name]], function(x) sum(is.na(x))))
}
```
</code></pre>
</div>


<button class="toggleButton">Show Duplicates Code Details</button>
<br><br>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r duplicate_rows, eval=TRUE}
# Looking for duplicate rows
# List of datasets
datasets <- list(
  daily_activity = daily_activity,
  daily_calories = daily_calories,
  daily_intensities = daily_intensities,
  daily_steps = daily_steps,
  hourly_calories = hourly_calories,
  hourly_intensities = hourly_intensities,
  hourly_steps = hourly_steps,
  minute_intensities = minute_intensities,
  minute_sleep = minute_sleep,
  sleep_day = sleep_day,
  weight_log = weight_log
)

# Check for duplicate rows in each dataset
for (name in names(datasets)) {
  cat("\nChecking for duplicate rows in:", name, "\n")
  duplicates <- sum(duplicated(datasets[[name]]))
  cat("Number of duplicate rows:", duplicates, "\n")
}
```

```{r sleep_day_duplicates, eval=FALSE}
# Found 3 duplicates in 'sleep_day'
# Identify duplicates
duplicates <- sleep_day[duplicated(sleep_day) | duplicated(sleep_day, fromLast = TRUE), ]

# Print the duplicate rows to confirm removal
print(duplicates)

# Remove duplicate rows, keeping only the first occurrence
sleep_day <- sleep_day[!duplicated(sleep_day), ]
```


```{r minute_sleep_duplicates, eval=FALSE}
# Found 543 duplicates in 'minute_sleep'
# Identify duplicates
duplicates <- minute_sleep[duplicated(minute_sleep) | duplicated(minute_sleep, fromLast = TRUE), ]

# Print the duplicate rows to confirm removal
print(duplicates)

# Remove duplicate rows, keeping only the first occurrence
minute_sleep <- minute_sleep[!duplicated(minute_sleep), ]
```
</code></pre>
</div>


<button class="toggleButton">Show Heartrate Duplicates Code Details</button>
<br><br>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r heartrate_seconds_duplicates, eval=TRUE}

# Running heart rate_seconds investigation separately to reduce likely hood of crash
# Created a function to process and remove duplicates in chunks
count_duplicates_in_chunks <- function(data, chunk_size = 100000) {
  num_chunks <- ceiling(nrow(data) / chunk_size)
  total_duplicates <- 0
  
  for (i in 1:num_chunks) {
    chunk <- data[((i - 1) * chunk_size + 1):min(i * chunk_size, nrow(data)), ]
    total_duplicates <- total_duplicates + sum(duplicated(chunk))
  }
  
  return(total_duplicates)
}

# Convert heart rate_seconds to data.table
heartrate_seconds_dt <- as.data.table(heartrate_seconds)

# Count duplicates using chunk processing
num_duplicates <- count_duplicates_in_chunks(heartrate_seconds_dt)

# Print the number of duplicates
cat("Number of duplicate rows in heartrate_seconds:", num_duplicates, "\n")
```
</code></pre>
</div>


<button class="toggleButton">Show Dataset Merge Code Details</button>
<br><br>
<div class="codeContent" style="display:none;">
  </code></pre>
```{r merging_datasets, eval=TRUE, message=FALSE, warning=FALSE}
# Merge multiple datasets (daily_activity, daily_intensities, daily_calories, daily_steps, sleep_day) into single dataset named 'daily_combined' using common columns "Id" and "ActivityDate"
# Removes any duplicate columns that have a ".y" suffix, ensuring only the original columns are retained in the daily_combined dataset.
daily_combined <- daily_activity %>%
  left_join(daily_intensities, by = c("Id", "ActivityDate")) %>%
  left_join(daily_calories, by = c("Id", "ActivityDate")) %>%
  left_join(daily_steps, by = c("Id", "ActivityDate")) %>%
  left_join(sleep_day, by = c("Id", "ActivityDate")) %>%
  select(-contains(".y"))

# Remove ".x" suffix from column names
colnames(daily_combined) <- gsub("\\.x$", "", colnames(daily_combined))

# Merge hourly datasets using common columns "Id" and "ActivityHour" and named 'hourly_combined'
# Remove any duplicate columns that have a ".y" suffix, ensuring only the original columns are retained in the hourly_combined dataset.
hourly_combined <- hourly_calories %>%
  left_join(hourly_intensities, by = c("Id", "ActivityHour")) %>%
  left_join(hourly_steps, by = c("Id", "ActivityHour")) %>%
  select(-contains(".y"))
```
</code></pre>
</div>
<br><br>

# <span style="color: #FF8967;">Phase 4: Analysis and Insights</span>

## User Engagement Patterns

```{r calculate_number_of_unique_users_per_metric, echo=FALSE, eval=TRUE}
# Calculate unique users for physical activity
activity_users <- daily_combined %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Physical Activity")

# Calculate unique users for heart rate
heartrate_users <- heartrate_seconds %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Heart Rate")

# Calculate unique users for sleep
sleep_users <- sleep_day %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Sleep")

# Calculate unique users for weight
weight_users <- weight_log %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Weight")

# Combine all user data into a single dataframe
user_data <- bind_rows(activity_users, heartrate_users, sleep_users, weight_users)

# Calculate percentages
total_users <- 33  # Total number of users
user_data <- user_data %>%
  mutate(Percentage = (Users / total_users) * 100)
```

```{r create_the_horizontal_bar_chart, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Create the horizontal bar chart with custom colors and annotations
ggplot(user_data, aes(x = Percentage, y = Metric, fill = Metric)) +
  geom_bar(stat = "identity", color = "lightgrey") +
  scale_fill_manual(values = c("Physical Activity" = "#ff6666", 
                               "Heart Rate" = "#ffb6b9", 
                               "Sleep" = "#FF8967", 
                               "Weight" = "#ffe6e6")) +
  geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
            position = position_stack(vjust = 0.5), 
            color = "black", 
            size = 3) +
  theme_minimal() +
  labs(title = "Percentage of Users Tracking Each Metric",
       x = "Percentage of Users",
       y = "Metric Type") +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),  
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt"))
```

- The data measures four primary metrics: Physical Activity, Sleep, Heart Rate, and Weight.  
- Among these metrics, users clearly valued tracking their physical activity the most, while weight and heart rate were tracked the least. This could be an opportunity to investigate why these metrics are less tracked and how to encourage more users.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_calculate_number_of_unique_users_per_metric, eval=FALSE}
# Calculate unique users for physical activity
activity_users <- daily_combined %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Physical Activity")

# Calculate unique users for heart rate
heartrate_users <- heartrate_seconds %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Heart Rate")

# Calculate unique users for sleep
sleep_users <- sleep_day %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Sleep")

# Calculate unique users for weight
weight_users <- weight_log %>%
  summarise(Users = n_distinct(Id)) %>%
  mutate(Metric = "Weight")

# Combine all user data into a single dataframe
user_data <- bind_rows(activity_users, heartrate_users, sleep_users, weight_users)

# Calculate percentages
total_users <- 33  # Total number of users
user_data <- user_data %>%
  mutate(Percentage = (Users / total_users) * 100)

# Create the horizontal bar chart with custom colors and annotations
ggplot(user_data, aes(x = Percentage, y = Metric, fill = Metric)) +
  geom_bar(stat = "identity", color = "lightgrey") +
  scale_fill_manual(values = c("Physical Activity" = "#ff6666", 
                               "Heart Rate" = "#ffb6b9", 
                               "Sleep" = "#FF8967", 
                               "Weight" = "#ffe6e6")) +
  geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
            position = position_stack(vjust = 0.5), 
            color = "black", 
            size = 3) +
  theme_minimal() +
  labs(title = "Percentage of Users Tracking Each Metric",
       x = "Percentage of Users",
       y = "Metric Type") +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),  
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt"))
```
</code></pre>
</div>
<br><br>

```{r usage_rate_of_participants, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Calculate the number of unique days each user has recorded data
user_days <- daily_combined %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))

# Categorize users based on the number of days they recorded data
user_days <- user_days %>%
  mutate(UsageCategory = case_when(
    NumberOfDays >= 1 & NumberOfDays <= 10 ~ "Minimal Use 1-10 Days",
    NumberOfDays >= 11 & NumberOfDays <= 20 ~ "Moderate Use 11-20 Days",
    NumberOfDays >= 21 & NumberOfDays <= 31 ~ "Consistent Use 21-31 Days"
  ))

# Adjust the order of the UsageCategory factor levels
user_days <- user_days %>%
  mutate(UsageCategory = factor(UsageCategory, levels = c("Consistent Use 21-31 Days", "Moderate Use 11-20 Days", "Minimal Use 1-10 Days")))

# Create a summary dataset for the pie chart
usage_summary <- user_days %>%
  count(UsageCategory) %>%
  mutate(Percentage = (n / sum(n)) * 100)

# Calculate label positions
usage_summary <- usage_summary %>%
  arrange(desc(UsageCategory)) %>%
  mutate(ypos = cumsum(Percentage) - 0.5 * Percentage)

# Create the pie chart with outside annotations
ggplot(usage_summary, aes(x = "", y = Percentage, fill = UsageCategory)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = c("Minimal Use 1-10 Days" = "#fff5f5", 
                               "Moderate Use 11-20 Days" = "#ffd9d9", 
                               "Consistent Use 21-31 Days" = "#FF8967")) +
  geom_text(aes(y = ypos, label = paste0(round(Percentage, 2), "%")), 
            color = "black", 
            size = 3.5, 
            nudge_x = 0.7) +  # Adjust position to place labels outside
  labs(title = "Usage Rate of Participants",
       x = "",
       y = "") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Remove x-axis text
        axis.ticks = element_blank(),   # Remove axis ticks
        panel.grid = element_blank(),   # Remove grid lines
        axis.title.x = element_blank(), # Remove x-axis title
        axis.title.y = element_blank()) # Remove y-axis title
```

- The high percentage of "Consistent Use" participants suggests that the device/platform is highly effective in engaging users regularly. This provides a solid foundation for both marketing the product and developing new features. 
- At the same time, the presence of "Moderate Use" and "Minimal Use" users indicates an opportunity to further refine and personalize the user experience to increase engagement across the board.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_usage_rate_of_participants, eval=FALSE}
# Calculate the number of unique days each user has recorded data
user_days <- daily_combined %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))

# Categorize users based on the number of days they recorded data
user_days <- user_days %>%
  mutate(UsageCategory = case_when(
    NumberOfDays >= 1 & NumberOfDays <= 10 ~ "Minimal Use 1-10 Days",
    NumberOfDays >= 11 & NumberOfDays <= 20 ~ "Moderate Use 11-20 Days",
    NumberOfDays >= 21 & NumberOfDays <= 31 ~ "Consistent Use 21-31 Days"
  ))

# Adjust the order of the UsageCategory factor levels
user_days <- user_days %>%
  mutate(UsageCategory = factor(UsageCategory, levels = c("Consistent Use 21-31 Days", "Moderate Use 11-20 Days", "Minimal Use 1-10 Days")))

# Create a summary dataset for the pie chart
usage_summary <- user_days %>%
  count(UsageCategory) %>%
  mutate(Percentage = (n / sum(n)) * 100)

# Calculate label positions
usage_summary <- usage_summary %>%
  arrange(desc(UsageCategory)) %>%
  mutate(ypos = cumsum(Percentage) - 0.5 * Percentage)

# Create the pie chart with outside annotations
ggplot(usage_summary, aes(x = "", y = Percentage, fill = UsageCategory)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = c("Minimal Use 1-10 Days" = "#fff5f5", 
                               "Moderate Use 11-20 Days" = "#ffd9d9", 
                               "Consistent Use 21-31 Days" = "#FF8967")) +
  geom_text(aes(y = ypos, label = paste0(round(Percentage, 2), "%")), 
            color = "black", 
            size = 3.5, 
            nudge_x = 0.7) +  # Adjust position to place labels outside
  labs(title = "Usage Rate of Participants",
       x = "",
       y = "") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Remove x-axis text
        axis.ticks = element_blank(),   # Remove axis ticks
        panel.grid = element_blank(),   # Remove grid lines
        axis.title.x = element_blank(), # Remove x-axis title
        axis.title.y = element_blank()) # Remove y-axis title
```
</code></pre>
</div>

<br><br>


```{r average_daily_device_usage, eval=TRUE, echo=FALSE}
# Calculate the number of unique days each user has recorded data
user_days <- daily_combined %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))


# Calculate the average, minimum, and maximum number of days across all users
summary_days <- user_days %>%
  summarise(
    AverageDays = mean(NumberOfDays, na.rm = TRUE),
    MinDays = min(NumberOfDays, na.rm = TRUE),
    MaxDays = max(NumberOfDays, na.rm = TRUE)
  )

# Add the percentage column to the summary_days tibble
summary_days <- summary_days %>%
  mutate(PercentageOfTotalDays = (AverageDays / 31) * 100)

# Print the updated summary statistics
print(summary_days)
```

- The average daily usage of their smart devices was measured at 28.5 days out of 31, indicating that participants used their devices 91.9% of the time.
- Only one user used their device for 4 days, while the next closest participant used their device for 16 days.

<button class="toggleButton">Show Tibble Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_average_daily_device_usage, eval=FALSE}
# Calculate the number of unique days each user has recorded data
user_days <- daily_combined %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))


# Calculate the average, minimum, and maximum number of days across all users
summary_days <- user_days %>%
  summarise(
    AverageDays = mean(NumberOfDays, na.rm = TRUE),
    MinDays = min(NumberOfDays, na.rm = TRUE),
    MaxDays = max(NumberOfDays, na.rm = TRUE)
  )

# Add the percentage column to the summary_days tibble
summary_days <- summary_days %>%
  mutate(PercentageOfTotalDays = (AverageDays / 31) * 100)

# Print the updated summary statistics
print(summary_days)
```
</code></pre>
</div>

<br><br>
<br><br>

## Activity Level Categories

- Fitabase categorizes activity levels into four groups: Sedentary, Lightly Active, Fairly Active, and Very Active.  
- According to this [LiveStrong](https://www.livestrong.com/article/401892-what-are-sedentary-moderate-high-activity-exercise-levels/) article, the "10,000 Steps Project" suggests five levels of activity. I combined the last two levels into the Very Active category (10,000 steps and above). By averaging the Daily Total Steps measured for each participant, I was able to categorize each participant into their respective Activity Level.<br><br>


```{r caterized_graphs_1, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Calculate the average for each column for each unique Id
avg_daily_combined <- daily_combined %>%
  group_by(Id) %>%
  summarise(
    AvgStepTotal = mean(StepTotal, na.rm = TRUE),
    AvgTotalDistance = mean(TotalDistance, na.rm = TRUE),
    AvgVeryActiveMinutes = mean(VeryActiveMinutes, na.rm = TRUE),
    AvgFairlyActiveMinutes = mean(FairlyActiveMinutes, na.rm = TRUE),
    AvgLightlyActiveMinutes = mean(LightlyActiveMinutes, na.rm = TRUE),
    AvgSedentaryMinutes = mean(SedentaryMinutes, na.rm = TRUE),
    AvgCalories = mean(Calories, na.rm = TRUE),
    AvgTotalMinutesAsleep = mean(TotalMinutesAsleep, na.rm = TRUE),
    AvgTotalTimeInBed = mean(TotalTimeInBed, na.rm = TRUE)
  )

# Group users into categories based on the adjusted 'AvgStepTotal' definitions
categorized_data <- avg_daily_combined %>%
  mutate(
    ActivityCategory = case_when(
      AvgStepTotal < 5000 ~ "Sedentary",
      AvgStepTotal >= 5000 & AvgStepTotal <= 7499 ~ "LightlyActive",
      AvgStepTotal >= 7500 & AvgStepTotal <= 9999 ~ "FairlyActive",
      AvgStepTotal >= 10000 ~ "VeryActive"
    )
  )

# Ensure the categories are ordered correctly
categorized_data$ActivityCategory <- factor(categorized_data$ActivityCategory, 
                                            levels = c("Sedentary", "LightlyActive", "FairlyActive", "VeryActive"))

# Create a summary dataset for the pie chart
pie_data <- categorized_data %>%
  count(ActivityCategory) %>%
  mutate(Percentage = n / sum(n) * 100)

# Define the custom colors
custom_colors <- c("Sedentary" = "#fff5f5", 
                   "LightlyActive" = "#ffd9d9", 
                   "FairlyActive" = "#FF8967", 
                   "VeryActive" = "#ff6666")

# Create the pie chart
ggplot(pie_data, aes(x = "", y = Percentage, fill = ActivityCategory)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = custom_colors) +
  geom_text(aes(label = paste0(round(Percentage, 2), "%")), 
            position = position_stack(vjust = 0.5), 
            color = "black", 
            size = 3) +
  labs(title = "Percentage of Users per Activity Category") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Remove x-axis text
        axis.ticks = element_blank(),   # Remove axis ticks
        panel.grid = element_blank(),   # Remove grid lines
        axis.title.x = element_blank(), # Remove x-axis title
        axis.title.y = element_blank()) # Remove y-axis title
```


#### Even Distribution
- The distribution across categories is relatively even, with no single category dominating the user base.
- This suggests that users have varied levels of activity, and the platform caters to a diverse group of individuals with different activity levels.<br><br>

#### Middle Range Dominance
- The middle categories (Lightly Active and Fairly Active) each account for 27.3% of users.
- This indicates that most users fall into moderate activity levels, which could be targeted for further engagement and improvement.<br><br>

#### Opportunities for Engagement
- Users in the Sedentary category could be targeted with personalized interventions and encouragement to increase their activity levels.  Reward systems could be utilized to encourage movement.
- Users in the Very Active category might be interested in advanced features or challenges to maintain their high activity levels.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_categorized_graphs_1, eval=FALSE}
# Calculate the average for each column for each unique Id
avg_daily_combined <- daily_combined %>%
  group_by(Id) %>%
  summarise(
    AvgStepTotal = mean(StepTotal, na.rm = TRUE),
    AvgTotalDistance = mean(TotalDistance, na.rm = TRUE),
    AvgVeryActiveMinutes = mean(VeryActiveMinutes, na.rm = TRUE),
    AvgFairlyActiveMinutes = mean(FairlyActiveMinutes, na.rm = TRUE),
    AvgLightlyActiveMinutes = mean(LightlyActiveMinutes, na.rm = TRUE),
    AvgSedentaryMinutes = mean(SedentaryMinutes, na.rm = TRUE),
    AvgCalories = mean(Calories, na.rm = TRUE),
    AvgTotalMinutesAsleep = mean(TotalMinutesAsleep, na.rm = TRUE),
    AvgTotalTimeInBed = mean(TotalTimeInBed, na.rm = TRUE)
  )

# Group users into categories based on the adjusted 'AvgStepTotal' definitions
categorized_data <- avg_daily_combined %>%
  mutate(
    ActivityCategory = case_when(
      AvgStepTotal < 5000 ~ "Sedentary",
      AvgStepTotal >= 5000 & AvgStepTotal <= 7499 ~ "LightlyActive",
      AvgStepTotal >= 7500 & AvgStepTotal <= 9999 ~ "FairlyActive",
      AvgStepTotal >= 10000 ~ "VeryActive"
    )
  )

# Ensure the categories are ordered correctly
categorized_data$ActivityCategory <- factor(categorized_data$ActivityCategory, 
                                            levels = c("Sedentary", "LightlyActive", "FairlyActive", "VeryActive"))

# Create a summary dataset for the pie chart
pie_data <- categorized_data %>%
  count(ActivityCategory) %>%
  mutate(Percentage = n / sum(n) * 100)

# Define the custom colors
custom_colors <- c("Sedentary" = "#fff5f5", 
                   "LightlyActive" = "#ffd9d9", 
                   "FairlyActive" = "#FF8967", 
                   "VeryActive" = "#ff6666")

# Create the pie chart
ggplot(pie_data, aes(x = "", y = Percentage, fill = ActivityCategory)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = custom_colors) +
  geom_text(aes(label = paste0(round(Percentage, 2), "%")), 
            position = position_stack(vjust = 0.5), 
            color = "black", 
            size = 3) +
  labs(title = "Percentage of Users per Activity Category") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Remove x-axis text
        axis.ticks = element_blank(),   # Remove axis ticks
        panel.grid = element_blank(),   # Remove grid lines
        axis.title.x = element_blank(), # Remove x-axis title
        axis.title.y = element_blank()) # Remove y-axis title
```
</code></pre>
</div>

<br><br>

### Time Distribution Across Activity Levels

```{r time_distribution_data_creation, eval=TRUE, echo=FALSE}
# Convert to data.table
setDT(minute_intensities)

# Get the range of numbers in the Intensity column
intensity_range <- minute_intensities[, .(min_intensity = min(Intensity, na.rm = TRUE), 
                                          max_intensity = max(Intensity, na.rm = TRUE))]

# Categorize activity levels
minute_intensities[, ActivityLevel := fifelse(Intensity == 0, "Sedentary",
                                              fifelse(Intensity == 1, "LightlyActive",
                                                      fifelse(Intensity == 2, "FairlyActive",
                                                              fifelse(Intensity == 3, "VeryActive", "Other"))))]

# Extract date from ActivityMinutes column
minute_intensities[, Date := as.Date(ActivityMinutes)]

# Calculate the amount of minutes spent in each ActivityLevel per user per day
daily_activity_levels <- minute_intensities[, .(MinutesSpent = .N), by = .(Id, Date, ActivityLevel)]

# Calculate the total minutes spent per user per day
total_minutes_per_day <- daily_activity_levels[, .(TotalMinutesSpent = sum(MinutesSpent, na.rm = TRUE)), by = .(Id, Date)]

# Merge to get the percentage of minutes spent in each activity level
daily_activity_levels <- merge(daily_activity_levels, total_minutes_per_day, by = c("Id", "Date"))
daily_activity_levels[, Percentage := (MinutesSpent / TotalMinutesSpent) * 100]

# Calculate the average percentage per activity level
average_percentage_per_level <- daily_activity_levels[, .(AvgPercentage = mean(Percentage, na.rm = TRUE)), by = .(Id, ActivityLevel)]

# Calculate average minutes spent per activity level per user
average_minutes_per_level <- daily_activity_levels[, .(AvgMinutesSpent = mean(MinutesSpent, na.rm = TRUE)), by = .(Id, ActivityLevel)]

# Merge average percentage back to the average_minutes_per_level dataset
average_minutes_per_level <- merge(average_minutes_per_level, average_percentage_per_level, by = c("Id", "ActivityLevel"))

# Add a column to convert minutes to hours
average_minutes_per_level[, AvgHoursSpent := AvgMinutesSpent / 60]

# Summarize the total average minutes spent, average percentage, and average hours spent for each activity level
summary_table <- average_minutes_per_level[, .(
  TotalAvgMinutesSpent = sum(AvgMinutesSpent, na.rm = TRUE),
  TotalAvgPercentage = mean(AvgPercentage, na.rm = TRUE),
  TotalAvgHoursSpent = sum(AvgHoursSpent, na.rm = TRUE)
), by = ActivityLevel]

# Ensure the total average percentage for each activity level
summary_table <- summary_table[, .(
  ActivityLevel,
  TotalAvgMinutesSpent,
  TotalAvgPercentage,
  TotalAvgHoursSpent
)]
```

```{r percentage_of_time_per_activity_level, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Define custom colors for the Activity Levels
activity_colors <- c(
  "Sedentary" = "#fff5f5",
  "LightlyActive" = "#ffd9d9",
  "FairlyActive" = "#FF8967",
  "VeryActive" = "#FF6666"
)

# Create labels for the legend
summary_table[, legend_label := paste0(ActivityLevel, " (", round(TotalAvgPercentage, 2), "%)")]

# Create the pie chart using ggplot2
ggplot(summary_table, aes(x = "", y = TotalAvgPercentage, fill = ActivityLevel)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = activity_colors, labels = summary_table$legend_label) +
  labs(title = "Percentage of Time Spent in Each Activity Level") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.ticks = element_blank(),   # Remove axis ticks
    panel.grid = element_blank(),   # Remove grid lines
    axis.title.x = element_blank(), # Remove x-axis title
    axis.title.y = element_blank(), # Remove y-axis title
    legend.position = "right"       # Position legend to the right
  ) +
  guides(fill = guide_legend(title = "Activity Level"))
```

- The majority of each day is spent at the sedentary level, accounting for 84.1% or 19 hours and 49 minutes.
- This is approximately composed of 7 hours in bed, likely 8-10 hours of working and commuting, and possibly an hour or two of watching TV. 
- Lightly Active time accounts for 14% or 3 hours and 25 minutes, likely spent on routine daily tasks.
- Very Active time is 1.97% or 28 minutes, potentially spent on vigorous exercise.
- Lastly, 1.43%, or 20 minutes, is spent in the Fairly Active category, which could also involve exercise.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_time_distribution, eval=FALSE}
# Convert to data.table
setDT(minute_intensities)

# Get the range of numbers in the Intensity column
intensity_range <- minute_intensities[, .(min_intensity = min(Intensity, na.rm = TRUE), 
                                          max_intensity = max(Intensity, na.rm = TRUE))]

# Categorize activity levels
minute_intensities[, ActivityLevel := fifelse(Intensity == 0, "Sedentary",
                                              fifelse(Intensity == 1, "LightlyActive",
                                                      fifelse(Intensity == 2, "FairlyActive",
                                                              fifelse(Intensity == 3, "VeryActive", "Other"))))]

# Extract date from ActivityMinutes column
minute_intensities[, Date := as.Date(ActivityMinutes)]

# Calculate the amount of minutes spent in each ActivityLevel per user per day
daily_activity_levels <- minute_intensities[, .(MinutesSpent = .N), by = .(Id, Date, ActivityLevel)]

# Calculate the total minutes spent per user per day
total_minutes_per_day <- daily_activity_levels[, .(TotalMinutesSpent = sum(MinutesSpent, na.rm = TRUE)), by = .(Id, Date)]

# Merge to get the percentage of minutes spent in each activity level
daily_activity_levels <- merge(daily_activity_levels, total_minutes_per_day, by = c("Id", "Date"))
daily_activity_levels[, Percentage := (MinutesSpent / TotalMinutesSpent) * 100]

# Calculate the average percentage per activity level
average_percentage_per_level <- daily_activity_levels[, .(AvgPercentage = mean(Percentage, na.rm = TRUE)), by = .(Id, ActivityLevel)]

# Calculate average minutes spent per activity level per user
average_minutes_per_level <- daily_activity_levels[, .(AvgMinutesSpent = mean(MinutesSpent, na.rm = TRUE)), by = .(Id, ActivityLevel)]

# Merge average percentage back to the average_minutes_per_level dataset
average_minutes_per_level <- merge(average_minutes_per_level, average_percentage_per_level, by = c("Id", "ActivityLevel"))

# Add a column to convert minutes to hours
average_minutes_per_level[, AvgHoursSpent := AvgMinutesSpent / 60]

# Summarize the total average minutes spent, average percentage, and average hours spent for each activity level
summary_table <- average_minutes_per_level[, .(
  TotalAvgMinutesSpent = sum(AvgMinutesSpent, na.rm = TRUE),
  TotalAvgPercentage = mean(AvgPercentage, na.rm = TRUE),
  TotalAvgHoursSpent = sum(AvgHoursSpent, na.rm = TRUE)
), by = ActivityLevel]

# Ensure the total average percentage for each activity level
summary_table <- summary_table[, .(
  ActivityLevel,
  TotalAvgMinutesSpent,
  TotalAvgPercentage,
  TotalAvgHoursSpent
)]

# Define custom colors for the Activity Levels
activity_colors <- c(
  "Sedentary" = "#fff5f5",
  "LightlyActive" = "#ffd9d9",
  "FairlyActive" = "#FF8967",
  "VeryActive" = "#FF6666"
)

# Create labels for the legend
summary_table[, legend_label := paste0(ActivityLevel, " (", round(TotalAvgPercentage, 2), "%)")]

# Create the pie chart using ggplot2
ggplot(summary_table, aes(x = "", y = TotalAvgPercentage, fill = ActivityLevel)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = activity_colors, labels = summary_table$legend_label) +
  labs(title = "Percentage of Time Spent in Each Activity Level") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.ticks = element_blank(),   # Remove axis ticks
    panel.grid = element_blank(),   # Remove grid lines
    axis.title.x = element_blank(), # Remove x-axis title
    axis.title.y = element_blank(), # Remove y-axis title
    legend.position = "right"       # Position legend to the right
  ) +
  guides(fill = guide_legend(title = "Activity Level"))
```
</code></pre>
</div>

<br><br>

```{r summary_table_tibble, eval=TRUE, echo=FALSE}
# Summarize the total average minutes spent, average percentage, and average hours spent for each activity level
summary_table <- average_minutes_per_level[, .(
  TotalAvgMinutesSpent = mean(AvgMinutesSpent, na.rm = TRUE),
  TotalAvgPercentage = mean(AvgPercentage, na.rm = TRUE),
  TotalAvgHoursSpent = mean(AvgHoursSpent, na.rm = TRUE)
), by = ActivityLevel]

# Print the summary table
tibble(summary_table)
```
<button class="toggleButton">Show Tibble Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_summary_table_tibble, eval=FALSE}
# Summarize the total average minutes spent, average percentage, and average hours spent for each activity level
summary_table <- average_minutes_per_level[, .(
  TotalAvgMinutesSpent = mean(AvgMinutesSpent, na.rm = TRUE),
  TotalAvgPercentage = mean(AvgPercentage, na.rm = TRUE),
  TotalAvgHoursSpent = mean(AvgHoursSpent, na.rm = TRUE)
), by = ActivityLevel]

# Print the summary table
tibble(summary_table)
```
</code></pre>
</div>

<br><br>
<br><br>


## Activity Patterns

### Peak Activity Times

```{r peak_activity_hours, echo=FALSE, results='hide', message=FALSE, fig.width=7, fig.height=3, fig.show='hold'}
# Separate Date and Time
hourly_steps <- hourly_steps %>%
  mutate(
    Date = as.Date(ActivityHour),
    Time = format(ActivityHour, format = "%H:%M:%S")
  )

# Summarize average steps by time
average_steps_by_time <- hourly_steps %>%
  group_by(Time) %>%
  summarize(average_steps = mean(StepTotal, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Time = factor(Time, levels = unique(Time)))
  
# Create the histogram
ggplot(average_steps_by_time, aes(x = Time, y = average_steps, fill = average_steps)) + 
  geom_col(color = "lightgrey") + 
  labs(title = "Peak Activity Hours", x = "Time", y = "Average Steps") + 
  scale_fill_gradient(low = "#ffe6e6", high = "#E04B4B") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

- High activity times range between 12 PM and 3 PM, with peak activity occurring between 5 PM and 7 PM.
- Peak activity is most likely due to post-work workouts.
- Send reminders or tips for physical activities during high activity times (12 PM to 3 PM) and peak times (5 PM to 7 PM). Additionally, launch fitness challenges or competitions that align with these peak activity periods to encourage participation and engagement.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_peak_activity_hours, eval=FALSE}
# Separate Date and Time
hourly_steps <- hourly_steps %>%
  mutate(
    Date = as.Date(ActivityHour),
    Time = format(ActivityHour, format = "%H:%M:%S")
  )

# Summarize average steps by time
average_steps_by_time <- hourly_steps %>%
  group_by(Time) %>%
  summarize(average_steps = mean(StepTotal, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Time = factor(Time, levels = unique(Time)))
  
# Create the histogram
ggplot(average_steps_by_time, aes(x = Time, y = average_steps, fill = average_steps)) + 
  geom_col(color = "lightgrey") + 
  labs(title = "Peak Activity Hours", x = "Time", y = "Average Steps") + 
  scale_fill_gradient(low = "#ffe6e6", high = "#E04B4B") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```
</code></pre>
</div>

<br><br>

### Average Steps, Distance, Calories


```{r average_steps_distance_calories, eval=TRUE, echo=FALSE}
# Calculate the averages for each user
user_averages <- daily_combined %>%
  group_by(Id) %>%
  summarise(
    AvgStepsPerDay = mean(StepTotal, na.rm = TRUE),
    AvgDistancePerDay = mean(TotalDistance, na.rm = TRUE),
    AvgCaloriesPerDay = mean(Calories, na.rm = TRUE)
  )

# Summarize the averages across all users
overall_averages <- user_averages %>%
  summarise(
    OverallAvgStepsPerDay = mean(AvgStepsPerDay, na.rm = TRUE),
    OverallAvgDistancePerDay = mean(AvgDistancePerDay, na.rm = TRUE),
    OverallAvgCaloriesPerDay = mean(AvgCaloriesPerDay, na.rm = TRUE)
  )

# Print the overall averages
print(overall_averages)
```

#### Steps
- The overall average steps fall almost exactly between the lightly active and fairly active categories at 7,519.27. This is close to the commonly recommended 10,000 steps per day, suggesting that users are relatively active but could still improve to reach the recommended goal through alerts, step challenges, encouragement, or reward systems.
- Identify users with significantly lower step counts and provide them with personalized interventions or encouragement to increase their activity levels.
- Segment users based on their average step counts to tailor content and features. For instance, beginners/sedentary users may need basic guidance and motivation, while more active users might benefit from advanced analytics and challenges.

#### Distance
- Unable to completely determine if distance is measured in km or M however, according to the [OmniCalculator site](https://www.omnicalculator.com/sports/steps-to-km), the distance is likely measured in km.
- In alignment with step counts, the average distance traveled could be slightly increased to healthier levels through encouragement features.

#### Calories
- The average daily caloric expenditure for each user from the Fitabase data is 2,282 calories, which is slightly below the average caloric burn for a moderately active person (2,437.5 calories) as referenced by  [WebMD](https://www.webmd.com/fitness-exercise/how-many-calories-do-i-burn-in-a-day). This suggests that, participants in the Fitabase data may be slightly less active than the general moderately active population.
-  There is potential to encourage users to increase their activity levels slightly to meet or exceed the average caloric expenditure of a moderately active person.
Note: This dataset is not gender-specific. Since Bellabeat is a female-focused brand, it is important to consider the average caloric expenditure of a moderately active female when utilizing this information for marketing and product improvements.

<button class="toggleButton">Show Tibble Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_average_steps_distance_calories, eval=FALSE}
# Calculate the averages for each user
user_averages <- daily_combined %>%
  group_by(Id) %>%
  summarise(
    AvgStepsPerDay = mean(StepTotal, na.rm = TRUE),
    AvgDistancePerDay = mean(TotalDistance, na.rm = TRUE),
    AvgCaloriesPerDay = mean(Calories, na.rm = TRUE)
  )

# Summarize the averages across all users
overall_averages <- user_averages %>%
  summarise(
    OverallAvgStepsPerDay = mean(AvgStepsPerDay, na.rm = TRUE),
    OverallAvgDistancePerDay = mean(AvgDistancePerDay, na.rm = TRUE),
    OverallAvgCaloriesPerDay = mean(AvgCaloriesPerDay, na.rm = TRUE)
  )

# Print the overall averages
print(overall_averages)
```
<br><</code></pre>
</div>

<br><br>


### Calories vs Steps

```{r calories_vs_steps_scatterplot, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Create the scatter plot with trendline
ggplot(daily_combined, aes(x = StepTotal, y = Calories)) +
  geom_point(color = "#FF8967", alpha = 0.5) +  # Scatter plot points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Trendline
  labs(title = "Scatter Plot of Total Steps vs Calories",
       x = "Total Steps",
       y = "Calories") +
  theme_minimal() +  # Minimal theme
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20))  # Add margins
```

- As expected, there is a strong positive correlation showing that as users' physical activity (measured by steps) increases, their caloric expenditure also rises. This underscores the importance of physical activity in managing energy balance and weight.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_calories_vs_steps_scatterplot, eval=FALSE}
# Create the scatter plot with trendline
ggplot(daily_combined, aes(x = StepTotal, y = Calories)) +
  geom_point(color = "#FF8967", alpha = 0.5) +  # Scatter plot points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Trendline
  labs(title = "Scatter Plot of Total Steps vs Calories",
       x = "Total Steps",
       y = "Calories") +
  theme_minimal() +  # Minimal theme
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20))  # Add margins
```
</code></pre>
</div>

<br><br>

### Daily Activity Stats

```{r daily_activity_stats, eval=TRUE, echo=FALSE}
# Add a new column for the day of the week
daily_combined <- daily_combined %>%
  mutate(DayOfWeek = weekdays(as.Date(ActivityDate)))

# Calculate the average TotalSteps and Calories by day of the week
average_activity <- daily_combined %>%
  group_by(DayOfWeek) %>%
  summarise(
    AvgStepTotal = mean(StepTotal, na.rm = TRUE),
    AvgCalories = mean(Calories, na.rm = TRUE)
  )

# Reorder the days of the week for plotting
average_activity$DayOfWeek <- factor(average_activity$DayOfWeek, 
                                     levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
```


```{r average_steps_bar_chart, echo=FALSE, results='hide', message=FALSE, fig.width=6, fig.height=3, fig.show='hold'}
# Define colors for steps categories
step_colors <- c("Sedentary" = "#fff5f5", 
                 "LightlyActive" = "#ffd9d9", 
                 "FairlyActive" = "#FF8967", 
                 "VeryActive" = "#ff6666")

# Categorize average steps
average_activity <- average_activity %>%
  mutate(StepCategory = case_when(
    AvgStepTotal < 5000 ~ "Sedentary",
    AvgStepTotal >= 5000 & AvgStepTotal <= 7499 ~ "LightlyActive",
    AvgStepTotal >= 7500 & AvgStepTotal <= 9999 ~ "FairlyActive",
    AvgStepTotal >= 10000 ~ "VeryActive"
  ))

# Plot average TotalSteps by day of the week with custom colors and horizontal lines
ggplot(average_activity, aes(x = DayOfWeek, y = AvgStepTotal, fill = StepCategory)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = step_colors) +
  geom_hline(yintercept = 5000, color = "black", linetype = "solid", linewidth = 0.25) +
  geom_hline(yintercept = 7500, color = "black", linetype = "solid", linewidth = 0.25) +
  geom_hline(yintercept = 10000, color = "black", linetype = "solid", linewidth = 0.25) +
  labs(title = "Average Total Steps by Day of the Week",
       x = "Day of the Week",
       y = "Average Total Steps") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20, unit = "pt"))
```

- Tuesday (8125 steps) and Saturday (8153 steps) have the highest average steps, both falling into the "FairlyActive" category.
- The weekend days (Saturday and Sunday) show a contrast in activity levels. Saturday is one of the most active days, while Sunday is one of the least active days.
- Sunday has the lowest average steps (6933), falling into the "LightlyActive" category.
- This could be an opportunity to develop, promote, and market weekend specific fitness plans or programs that cater to both high activity days like Saturday and low activity days like Sunday.
- Highlight the benefits of staying active over the weekend by offering specific workout challenges and promoting family-focused active activities. This could broaden the appeal, encouraging users to involve their family members, potentially increasing the number of new users and enhancing overall user satisfaction and loyalty.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_average_steps_bar_chart, eval=FALSE}
# Add a new column for the day of the week
daily_combined <- daily_combined %>%
  mutate(DayOfWeek = weekdays(as.Date(ActivityDate)))

# Calculate the average TotalSteps and Calories by day of the week
average_activity <- daily_combined %>%
  group_by(DayOfWeek) %>%
  summarise(
    AvgStepTotal = mean(StepTotal, na.rm = TRUE),
    AvgCalories = mean(Calories, na.rm = TRUE)
  )

# Reorder the days of the week for plotting
average_activity$DayOfWeek <- factor(average_activity$DayOfWeek, 
                                     levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))

# Define colors for steps categories
step_colors <- c("Sedentary" = "#fff5f5", 
                 "LightlyActive" = "#ffd9d9", 
                 "FairlyActive" = "#FF8967", 
                 "VeryActive" = "#ff6666")

# Categorize average steps
average_activity <- average_activity %>%
  mutate(StepCategory = case_when(
    AvgStepTotal < 5000 ~ "Sedentary",
    AvgStepTotal >= 5000 & AvgStepTotal <= 7499 ~ "LightlyActive",
    AvgStepTotal >= 7500 & AvgStepTotal <= 9999 ~ "FairlyActive",
    AvgStepTotal >= 10000 ~ "VeryActive"
  ))

# Plot average TotalSteps by day of the week with custom colors and horizontal lines
ggplot(average_activity, aes(x = DayOfWeek, y = AvgStepTotal, fill = StepCategory)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = step_colors) +
  geom_hline(yintercept = 5000, color = "black", linetype = "solid", linewidth = 0.25) +
  geom_hline(yintercept = 7500, color = "black", linetype = "solid", linewidth = 0.25) +
  geom_hline(yintercept = 10000, color = "black", linetype = "solid", linewidth = 0.25) +
  labs(title = "Average Total Steps by Day of the Week",
       x = "Day of the Week",
       y = "Average Total Steps") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20, unit = "pt"))
```
</code></pre>
</div>

<br><br>

```{r average_calories_bar_chart, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Plot average Calories by day of the week with reference lines and annotations
ggplot(average_activity, aes(x = DayOfWeek, y = AvgCalories)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  geom_hline(yintercept = 2437.5, color = "#ff6666", linetype = "solid", linewidth = 0.4) +
  geom_hline(yintercept = 2150, color = "#FF8967", linetype = "solid", linewidth = 0.4) +
  annotate("text", x = 4, y = 2437.5, label = "AAP", 
           color = "black", vjust = 0.5) +
  annotate("text", x = 4, y = 2150, label = "AAF", 
           color = "black", vjust = 1) +
  labs(title = "Average Calories Burned by Day of the Week",
       x = "Day of the Week",
       y = "Average Calories Burned") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20, unit = "pt"))

```

- AAP = Average Active Person Caloric Burn (2437.5)
- AAF = Average Active Female Caloric Burn (2150)
- Since demographic data is nonexistent, we must assume these results represent a mixed-gender population. However, setting a daily caloric target based on gender and age could help motivate users more effectively.
- The average calories burned range from 2199.571 to 2356.013, showing a relatively consistent caloric burn across the week.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_average_calories_bar_chart, eval=FALSE}
# Plot average Calories by day of the week with reference lines and annotations
ggplot(average_activity, aes(x = DayOfWeek, y = AvgCalories)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  geom_hline(yintercept = 2437.5, color = "#ff6666", linetype = "solid", linewidth = 0.4) +
  geom_hline(yintercept = 2150, color = "#FF8967", linetype = "solid", linewidth = 0.4) +
  annotate("text", x = 4, y = 2437.5, label = "AAP", 
           color = "black", vjust = 0.5) +
  annotate("text", x = 4, y = 2150, label = "AAF", 
           color = "black", vjust = 1) +
  labs(title = "Average Calories Burned by Day of the Week",
       x = "Day of the Week",
       y = "Average Calories Burned") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20, unit = "pt"))
```
</code></pre>
</div>

<br><br>
<br><br>

## Sleep Patterns

### Sleep Metrics

```{r sleep_metrics, eval=TRUE, echo=FALSE}
# Calculate the number of distinct days each user recorded sleep data
user_days <- sleep_day %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))

# Summarise total minutes asleep and total time in be for each user
summary_sleep <- sleep_day %>%
  group_by(Id) %>%
  summarise(
    TotalMinutesAsleep = sum(TotalMinutesAsleep, na.rm = TRUE),
    TotalTimeInBed = sum(TotalTimeInBed, na.rm = TRUE)
  )

# Calculate averages for minutes asleep and time in bed, then convert to hours
summary_sleep <- summary_sleep %>%
  left_join(user_days, by = "Id") %>%
  mutate(
    AvgMinutesAsleep = TotalMinutesAsleep / NumberOfDays,
    AvgTimeInBed = TotalTimeInBed / NumberOfDays,
    AvgHoursAsleep = AvgMinutesAsleep / 60,
    AvgHoursInBed = AvgTimeInBed / 60
  )

# Calculate the overall average minutes asleep and time in bed
overall_averages <- summary_sleep %>%
  summarise(
    OverallAvgMinutesAsleep = mean(AvgMinutesAsleep, na.rm = TRUE),
    OverallAvgTimeInBed = mean(AvgTimeInBed, na.rm = TRUE),
    OverallAvgHoursAsleep = OverallAvgMinutesAsleep / 60,
    OverallAvgHoursInBed = OverallAvgTimeInBed / 60
  )
```

```{r overall_avg_hours_asleep_and_in_bed, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Create a data frame for plotting
plot_data <- tibble(
  Metric = c("Average Hours Asleep", "Average Hours In Bed"),
  Value = c(overall_averages$OverallAvgHoursAsleep, overall_averages$OverallAvgHoursInBed),
  Color = c("#FF8967", "#ffb6b9")
)

# Plot the horizontal bar graph
ggplot(plot_data, aes(x = Value, y = Metric, fill = Color)) +
  geom_bar(stat = "identity", color = "lightgrey", width = 0.5) +
  geom_text(aes(label = sprintf("%.2f", Value)), hjust = -0.2, color = "black", size = 3.5) +  # Annotate each bar with exact numbers to 2 decimal places
  scale_fill_identity() +
  labs(title = "Overall Average Hours Asleep and In Bed",
       x = "Hours",
       y = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(size = 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

```
<br><br>

- Two metrics were recorded: TotalTimeAsleep and TotalTimeInBed. Both were converted into hours.
- On average, users spent 7 hours in bed and 6hrs 19 mins asleep.  This falls 41 minutes short of the recommended sleep time for adults, as advised by the [Sleep Foundation.](https://www.sleepfoundation.org/how-sleep-works/how-much-sleep-do-we-really-need#:~:text=Most%20healthy%20adults%20need%20at,happy%2C%20healthy%2C%20and%20sharp.)
- This presents an opportunity to promote healthier sleep patterns by providing content and tools to help users manage their time better and develop relaxing end-of-day routines. Features can include bedtime reminders, relaxation techniques, and advice on minimizing screen time before bed.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_overall_avg_hours_asleep_and_in_bed, eval=FALSE}
# Calculate the number of distinct days each user recorded sleep data
user_days <- sleep_day %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))

# Summarise total minutes asleep and total time in be for each user
summary_sleep <- sleep_day %>%
  group_by(Id) %>%
  summarise(
    TotalMinutesAsleep = sum(TotalMinutesAsleep, na.rm = TRUE),
    TotalTimeInBed = sum(TotalTimeInBed, na.rm = TRUE)
  )

# Calculate averages for minutes asleep and time in bed, then convert to hours
summary_sleep <- summary_sleep %>%
  left_join(user_days, by = "Id") %>%
  mutate(
    AvgMinutesAsleep = TotalMinutesAsleep / NumberOfDays,
    AvgTimeInBed = TotalTimeInBed / NumberOfDays,
    AvgHoursAsleep = AvgMinutesAsleep / 60,
    AvgHoursInBed = AvgTimeInBed / 60
  )

# Calculate the overall average minutes asleep and time in bed
overall_averages <- summary_sleep %>%
  summarise(
    OverallAvgMinutesAsleep = mean(AvgMinutesAsleep, na.rm = TRUE),
    OverallAvgTimeInBed = mean(AvgTimeInBed, na.rm = TRUE),
    OverallAvgHoursAsleep = OverallAvgMinutesAsleep / 60,
    OverallAvgHoursInBed = OverallAvgTimeInBed / 60
  )
# Create a data frame for plotting
plot_data <- tibble(
  Metric = c("Average Hours Asleep", "Average Hours In Bed"),
  Value = c(overall_averages$OverallAvgHoursAsleep, overall_averages$OverallAvgHoursInBed),
  Color = c("#FF8967", "#ffb6b9")
)

# Plot the horizontal bar graph
ggplot(plot_data, aes(x = Value, y = Metric, fill = Color)) +
  geom_bar(stat = "identity", color = "lightgrey", width = 0.5) +
  geom_text(aes(label = sprintf("%.2f", Value)), hjust = -0.2, color = "black", size = 3.5) +  # Annotate each bar with exact numbers to 2 decimal places
  scale_fill_identity() +
  labs(title = "Overall Average Hours Asleep and In Bed",
       x = "Hours",
       y = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(size = 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )
```
</code></pre>
</div>

<br><br>

```{r usage_rate_of_sleep_feature, echo=FALSE, results='hide', message=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Calculate the number of distinct days each user recorded sleep data
user_days <- sleep_day %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))

# Categorize users based on the number of days they recorded data
user_days <- user_days %>%
  mutate(UsageCategory = case_when(
    NumberOfDays >= 1 & NumberOfDays <= 10 ~ "Minimal Use 1-10 Days",
    NumberOfDays >= 11 & NumberOfDays <= 20 ~ "Moderate Use 11-20 Days",
    NumberOfDays >= 21 & NumberOfDays <= 31 ~ "Consistent Use 21-31 Days"
  ))

# Adjust the order of the UsageCategory factor levels
user_days <- user_days %>%
  mutate(UsageCategory = factor(UsageCategory, levels = c("Consistent Use 21-31 Days", "Moderate Use 11-20 Days", "Minimal Use 1-10 Days")))


# Create a summary dataset for the pie chart
usage_summary <- user_days %>%
  count(UsageCategory) %>%
  mutate(Percentage = (n / sum(n)) * 100)

# Calculate label positions
usage_summary <- usage_summary %>%
  arrange(desc(UsageCategory)) %>%
  mutate(ypos = cumsum(Percentage) - 0.5 * Percentage)

# Create the pie chart with outside annotations
ggplot(usage_summary, aes(x = "", y = Percentage, fill = UsageCategory)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = c("Minimal Use 1-10 Days" = "#fff5f5", 
                               "Moderate Use 11-20 Days" = "#ffd9d9", 
                               "Consistent Use 21-31 Days" = "#FF8967")) +
  geom_text(aes(y = ypos, label = paste0(round(Percentage, 2), "%")), 
            color = "black", 
            size = 3.5, 
            nudge_x = 0.7) +  # Adjust position to place labels outside
  labs(title = "Usage Rate of Sleep Feature",
       x = "",
       y = "") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Remove x-axis text
        axis.ticks = element_blank(),   # Remove axis ticks
        panel.grid = element_blank(),   # Remove grid lines
        axis.title.x = element_blank(), # Remove x-axis title
        axis.title.y = element_blank()) # Remove y-axis title
```

- Currently, 72.7% of all participants utilize the sleep recording feature.
- Among these users, only 50% can be categorized as consistent users of this feature, with 12.5% using it moderately and over a third (37.5%) using it minimally.
- On average, users recorded their sleep data only 17 out of 31 days, or 55% of the time.
- Less than desirable usage could be due to charging device overnight.  Further exploration of this is needed.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_usage_rate_of_sleep_feature, eval=FALSE}
# Calculate the number of distinct days each user recorded sleep data
user_days <- sleep_day %>%
  group_by(Id) %>%
  summarise(NumberOfDays = n_distinct(ActivityDate))

# Categorize users based on the number of days they recorded data
user_days <- user_days %>%
  mutate(UsageCategory = case_when(
    NumberOfDays >= 1 & NumberOfDays <= 10 ~ "Minimal Use 1-10 Days",
    NumberOfDays >= 11 & NumberOfDays <= 20 ~ "Moderate Use 11-20 Days",
    NumberOfDays >= 21 & NumberOfDays <= 31 ~ "Consistent Use 21-31 Days"
  ))

# Adjust the order of the UsageCategory factor levels
user_days <- user_days %>%
  mutate(UsageCategory = factor(UsageCategory, levels = c("Consistent Use 21-31 Days", "Moderate Use 11-20 Days", "Minimal Use 1-10 Days")))


# Create a summary dataset for the pie chart
usage_summary <- user_days %>%
  count(UsageCategory) %>%
  mutate(Percentage = (n / sum(n)) * 100)

# Calculate label positions
usage_summary <- usage_summary %>%
  arrange(desc(UsageCategory)) %>%
  mutate(ypos = cumsum(Percentage) - 0.5 * Percentage)

# Create the pie chart with outside annotations
ggplot(usage_summary, aes(x = "", y = Percentage, fill = UsageCategory)) +
  geom_bar(width = 1, stat = "identity", color = "lightgrey") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = c("Minimal Use 1-10 Days" = "#fff5f5", 
                               "Moderate Use 11-20 Days" = "#ffd9d9", 
                               "Consistent Use 21-31 Days" = "#FF8967")) +
  geom_text(aes(y = ypos, label = paste0(round(Percentage, 2), "%")), 
            color = "black", 
            size = 3.5, 
            nudge_x = 0.7) +  # Adjust position to place labels outside
  labs(title = "Usage Rate of Sleep Feature",
       x = "",
       y = "") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  # Remove x-axis text
        axis.ticks = element_blank(),   # Remove axis ticks
        panel.grid = element_blank(),   # Remove grid lines
        axis.title.x = element_blank(), # Remove x-axis title
        axis.title.y = element_blank()) # Remove y-axis title
```
</code></pre>
</div>

<br><br>

### Sleep Quality Vs Physical Activity

```{r step_total_vs_sleep_length, echo=FALSE, results='hide', message=FALSE, warning=FALSE, fig.width=5, fig.height=3, fig.show='hold'}
# Create the scatter plot with trendline
ggplot(daily_combined, aes(x = StepTotal, y = TotalMinutesAsleep)) +
  geom_point(color = "#FF8967", alpha = 0.5) +  # Scatter plot points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Trendline
  labs(title = "Scatter Plot of Total Steps vs Total Minutes Asleep",
       x = "Step Total",
       y = "Total Minutes Asleep") +
  theme_minimal() +  # Minimal theme
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20))  # Add margins
```

- Interestingly, there is a slight negative correlation between physical exertion and sleep duration, which contradicts the advice from the [Sleep Foundation.](https://www.sleepfoundation.org/physical-activity/exercise-and-sleep#:~:text=Exercising%20also%20improves%20sleep,in%20bed%20during%20the%20night.)
- However, this could be due to other factors not recorded in the dataset, including diet, screen time, TV habits, water intake, stress, and work/life commitments.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_step_total_vs_sleep_length, eval=FALSE}
# Create the scatter plot with trendline
ggplot(daily_combined, aes(x = StepTotal, y = TotalMinutesAsleep)) +
  geom_point(color = "#FF8967", alpha = 0.5) +  # Scatter plot points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Trendline
  labs(title = "Scatter Plot of Total Steps vs Total Minutes Asleep",
       x = "Step Total",
       y = "Total Minutes Asleep") +
  theme_minimal() +  # Minimal theme
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        plot.margin = margin(t = 20, r = 20, b = 20, l = 20))  # Add margins
```
</code></pre>
</div>

<br><br>
<br><br>


## Heart Rate

```{r min_max_avg_bpm, echo=FALSE, results='hide', message=FALSE, fig.width=6, fig.height=3, fig.show='hold'}
# Summarize max, min, and average bpm by Id
bpm_summary <- heartrate_seconds_dt %>%
  group_by(Id) %>%
  summarize(
    max_bpm = max(Bpm, na.rm = TRUE),
    min_bpm = min(Bpm, na.rm = TRUE),
    average_bpm = mean(Bpm, na.rm = TRUE)
  )

# Overall Bpm Summary
overall_bpm_summary <- bpm_summary %>%
  summarize(
    max_bpm = max(max_bpm, na.rm = TRUE),
    min_bpm = min(min_bpm, na.rm = TRUE),
    average_bpm = mean(average_bpm, na.rm = TRUE)
  )

# Create a summary table
plot_data <- data.frame(
  Metric = c("Max Bpm", "Min Bpm", "Average Bpm"),
  Value = c(overall_bpm_summary$max_bpm,
            overall_bpm_summary$min_bpm,
            overall_bpm_summary$average_bpm)
)

# Create the bar plot
ggplot(plot_data, aes(x = Metric, y = Value, fill = Metric)) +
  geom_bar(stat = "identity", color = "lightgrey") +
  geom_text(aes(label = round(Value, 2)), vjust = -0.5, color = "black", size = 3) +  # Adjust size here
  scale_fill_manual(values = c("Max Bpm" = "#ff6666", "Min Bpm" = "#ffe6e6", "Average Bpm" = "#FF8967")) +
  labs(title = "Overall Bpm Summary", x = "", y = "Bpm") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12, face = "bold"),
        axis.text.y = element_text(size = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ylim(0, max(plot_data$Value) * 1.1)  # Increase y-axis height
```

- Only 14 users (42.4%) utilized this feature.
- The average bpm of 79.98 falls within the normal resting heart rate range (60-100), which is good.
- The maximum heart rate recorded was 203, which is within the expected range. A commonly used formula to estimate your maximum heart rate is 220 minus your age.
- The lowest heart rate recorded was 36, which is lower than that of a well-trained athlete (40 bpm).
- All general healthy heart rate ranges referenced from the [Mayo Clinic](https://www.mayoclinic.org/healthy-lifestyle/fitness/expert-answers/heart-rate/faq-20057979#:~:text=A%20normal%20resting%20heart%20rate%20for%20adults%20ranges%20from%2060,to%2040%20beats%20per%20minute.https://www.mayoclinic.org/healthy-lifestyle/fitness/expert-answers/heart-rate/faq-20057979#:~:text=A%20normal%20resting%20heart%20rate%20for%20adults%20ranges%20from%2060,to%2040%20beats%20per%20minute.), and [Heart Online](https://www.heartonline.org.au/resources/calculators/target-heart-rate-calculator).

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_min_max_avg_bpm, eval=FALSE}
# Summarize max, min, and average bpm by Id
bpm_summary <- heartrate_seconds_dt %>%
  group_by(Id) %>%
  summarize(
    max_bpm = max(Bpm, na.rm = TRUE),
    min_bpm = min(Bpm, na.rm = TRUE),
    average_bpm = mean(Bpm, na.rm = TRUE)
  )

# Overall Bpm Summary
overall_bpm_summary <- bpm_summary %>%
  summarize(
    max_bpm = max(max_bpm, na.rm = TRUE),
    min_bpm = min(min_bpm, na.rm = TRUE),
    average_bpm = mean(average_bpm, na.rm = TRUE)
  )

# Create a summary table
plot_data <- data.frame(
  Metric = c("Max Bpm", "Min Bpm", "Average Bpm"),
  Value = c(overall_bpm_summary$max_bpm,
            overall_bpm_summary$min_bpm,
            overall_bpm_summary$average_bpm)
)

# Create the bar plot
ggplot(plot_data, aes(x = Metric, y = Value, fill = Metric)) +
  geom_bar(stat = "identity", color = "lightgrey") +
  geom_text(aes(label = round(Value, 2)), vjust = -0.5, color = "black", size = 3) +  # Adjust size here
  scale_fill_manual(values = c("Max Bpm" = "#ff6666", "Min Bpm" = "#ffe6e6", "Average Bpm" = "#FF8967")) +
  labs(title = "Overall Bpm Summary", x = "", y = "Bpm") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12, face = "bold"),
        axis.text.y = element_text(size = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ylim(0, max(plot_data$Value) * 1.1)  # Increase y-axis height
```
</code></pre>
</div>

<br><br>
<br><br>

## Weight Insights

```{r weight_insights, echo=FALSE, results='hide', message=FALSE, fig.width=7, fig.height=3, fig.show='hold'}
# Summarize max, min, and average WeightKg, WeightPounds, and BMI by Id
weight_summary <- weight_log %>%
  group_by(Id) %>%
  summarize(
    max_kg = max(WeightKg, na.rm = TRUE),
    min_kg = min(WeightKg, na.rm = TRUE),
    avg_kg = mean(WeightKg, na.rm = TRUE),
    max_lb = max(WeightPounds, na.rm = TRUE),
    min_lb = min(WeightPounds, na.rm = TRUE),
    avg_lb = mean(WeightPounds, na.rm = TRUE),
    max_BMI = max(BMI, na.rm = TRUE),
    min_BMI = min(BMI, na.rm = TRUE),
    avg_BMI = mean(BMI, na.rm = TRUE)
  )

# Overall Bpm Summary
overall_weight_summary <- weight_summary %>%
  summarize(
    max_kg = max(max_kg, na.rm = TRUE),
    min_kg = min(min_kg, na.rm = TRUE),
    avg_kg = mean(avg_kg, na.rm = TRUE),
    max_lb = max(max_lb, na.rm = TRUE),
    min_lb = min(min_lb, na.rm = TRUE),
    avg_lb = mean(avg_lb, na.rm = TRUE),
    max_BMI = max(max_BMI, na.rm = TRUE),
    min_BMI = min(min_BMI, na.rm = TRUE),
    avg_BMI = mean(avg_BMI, na.rm = TRUE)
  )

# Create a summary table for the plot
plot_data <- data.frame(
  Metric = rep(c("Weight (kg)", "Weight (lb)", "BMI"), each = 3),
  Statistic = rep(c("Max", "Min", "Average"), 3),
  Value = c(overall_weight_summary$max_kg, overall_weight_summary$min_kg, overall_weight_summary$avg_kg,
            overall_weight_summary$max_lb, overall_weight_summary$min_lb, overall_weight_summary$avg_lb,
            overall_weight_summary$max_BMI, overall_weight_summary$min_BMI, overall_weight_summary$avg_BMI)
)

# Create the grouped bar plot
ggplot(plot_data, aes(x = Metric, y = Value, fill = Statistic)) +
  geom_bar(stat = "identity", position = "dodge", color = "lightgrey") +
  geom_text(aes(label = round(Value, 2)), position = position_dodge(width = 0.9), vjust = -0.5, color = "black", size = 3) +  # Adjust size here
  scale_fill_manual(values = c("Max" = "#ff6666", "Min" = "#ffe6e6", "Average" = "#FF8967")) +
  labs(title = "Overall Weight and BMI Summary", x = "Metric", y = "Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12, face = "bold", angle = 45, hjust = 1),
        axis.text.y = element_text(size = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ylim(0, max(plot_data$Value) * 1.1)  # Increase y-axis height
```

- This feature is utilized by the smallest group of users, accounting for 24.2% or 8 people.
- Those who used this feature fall into a diverse weight range, from 52.6 kg (116 lbs) to 134 kg (294 lbs).
- The average weight is 77.8 kg (171.54 lbs), and the average BMI is 28.
- Since the average BMI of 28 falls into the overweight category, as referenced by the [CDC](https://www.cdc.gov/healthyweight/assessing/index.html), providing gentle support towards achieving a healthier range is recommended.
- The BMI values range from 21.5 to 47.5. Creating and providing segmented advice based on BMI categories could significantly enhance user engagement and the utilization of this feature.

<button class="toggleButton">Show Graph Code Details</button>
<div class="codeContent" style="display:none;">
  </code></pre>

```{r toggle_weight_insights, eval=FALSE}
# Summarize max, min, and average WeightKg, WeightPounds, and BMI by Id
weight_summary <- weight_log %>%
  group_by(Id) %>%
  summarize(
    max_kg = max(WeightKg, na.rm = TRUE),
    min_kg = min(WeightKg, na.rm = TRUE),
    avg_kg = mean(WeightKg, na.rm = TRUE),
    max_lb = max(WeightPounds, na.rm = TRUE),
    min_lb = min(WeightPounds, na.rm = TRUE),
    avg_lb = mean(WeightPounds, na.rm = TRUE),
    max_BMI = max(BMI, na.rm = TRUE),
    min_BMI = min(BMI, na.rm = TRUE),
    avg_BMI = mean(BMI, na.rm = TRUE)
  )

# Overall Bpm Summary
overall_weight_summary <- weight_summary %>%
  summarize(
    max_kg = max(max_kg, na.rm = TRUE),
    min_kg = min(min_kg, na.rm = TRUE),
    avg_kg = mean(avg_kg, na.rm = TRUE),
    max_lb = max(max_lb, na.rm = TRUE),
    min_lb = min(min_lb, na.rm = TRUE),
    avg_lb = mean(avg_lb, na.rm = TRUE),
    max_BMI = max(max_BMI, na.rm = TRUE),
    min_BMI = min(min_BMI, na.rm = TRUE),
    avg_BMI = mean(avg_BMI, na.rm = TRUE)
  )

# Create a summary table for the plot
plot_data <- data.frame(
  Metric = rep(c("Weight (kg)", "Weight (lb)", "BMI"), each = 3),
  Statistic = rep(c("Max", "Min", "Average"), 3),
  Value = c(overall_weight_summary$max_kg, overall_weight_summary$min_kg, overall_weight_summary$avg_kg,
            overall_weight_summary$max_lb, overall_weight_summary$min_lb, overall_weight_summary$avg_lb,
            overall_weight_summary$max_BMI, overall_weight_summary$min_BMI, overall_weight_summary$avg_BMI)
)

# Create the grouped bar plot
ggplot(plot_data, aes(x = Metric, y = Value, fill = Statistic)) +
  geom_bar(stat = "identity", position = "dodge", color = "lightgrey") +
  geom_text(aes(label = round(Value, 2)), position = position_dodge(width = 0.9), vjust = -0.5, color = "black", size = 3) + 
  scale_fill_manual(values = c("Max" = "#ff6666", "Min" = "#ffe6e6", "Average" = "#FF8967")) +
  labs(title = "Overall Weight and BMI Summary", x = "Metric", y = "Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12, face = "bold", angle = 45, hjust = 1),
        axis.text.y = element_text(size = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ylim(0, max(plot_data$Value) * 1.1)  # Increase y-axis height
```
</code></pre>
</div>
<br><br>

# <span style="color: #FF8967;">Phase 5: Share and Act</span>

### User Engagement:

**Insight:** Users highly value tracking their physical activity, showing effective engagement among consistent users. However, there are significant opportunities to further engage moderate and minimal use users.

**Actionable Recommendations**

  1.	**Enhance Physical Activity Features:** Survey users for feature requests, invest in workout logs, personalized recommendations, and advanced analytics. 
  2.	**Social Engagement:** Introduce activity challenges, group workouts, and leader boards.
  3.	**Add Heart Monitoring to Standard Physical Activity Tracking:** The device already records heart rate data. To increase heart rate monitoring usage, integrate it with the most used category—physical activity tracking.
  4.	**Re-engagement Campaigns:** Implement campaigns with tips, new features, and incentives. 
  5.	**Target Low Usage:** Provide support and interventions for users with low device usage.
  6.	**Utilize Testimonials:** Leverage consistent users through testimonials in marketing and engage them in beta testing.

<br><br>

### Activity Categories:

**Insight:** The platform effectively caters to a diverse range of activity levels, with an even distribution across categories. While Lightly Active and Fairly Active users each make up 27.3% of the user base, a significant portion falls into the Sedentary category. 

**Actionable Recommendations**

  1.	**Tailored Content for All Activity Levels:** Develop tailored beginner, intermediate, and advanced fitness plans to ensure users of all levels feel catered to.  Use targeted communication for personalized messaging.
  2.	**Engagement Programs:** Create challenges and implement reward systems for transitioning activity levels, focusing on Lightly Active and Fairly Active users.
  3.	**Support Sedentary Users:** Develop personalized interventions and gentle reminders, provide easy-to-follow activity suggestions, and small, achievable goals.
  4.	**Advanced Features:** Offer detailed performance metrics and high-intensity challenges for Very Active users.

<br><br>

### Activity Patterns:

**Insight:** The analysis of time distribution shows clear user behavior patterns, with high activity times between 12 PM - 3 PM and peak activity from 5 PM - 7 PM, likely due to post-work workouts. The average steps per day are 7,527, close to the recommended 10,000, and the average daily caloric expenditure is 2,282 calories, slightly below the moderately active average.

**Actionable Recommendations**

  1.	**Custom Recommendations:** Offer personalized activity plans based on user behavior.
  2.	**Behavioural Nudges:** Implement reminders for healthy habits and peak activity times.
  3.	**Step Challenges:** Encourage users to reach 10,000 steps per day through challenges and rewards.  Provide personalized interventions for low step counts, and tailor content based on activity levels.
  4.	**Nutritional Guidance:** Provide advice to balance caloric intake and expenditure.

<br><br>

### Daily Activity Stats:

**Insight:** Tuesday and Saturday have the highest average steps, indicating high activity, while Sunday is less active. Promoting family-focused activities over the weekend can boost engagement. Setting daily caloric targets based on gender and age could further motivate users.

**Actionable Recommendations**

  1.	**Highlight High-Step Days:** Use motivational messages and rewards for high step days.
  2.	**Weekend Activity Plans:** Develop and promote weekend-specific fitness plans for high-activity Saturdays and market low-intensity workouts for Sundays, including family-focused activities.
  3.	**Personalized Caloric Targets:** Implement features for setting daily caloric targets based on gender, age, and activity level for effective motivation.

<br><br>

### Sleep Patterns:

**Insight:** Users spend an average of 7 hours in bed but only 6 hours and 19 minutes asleep, falling 41 minutes short of the recommended sleep time. While 72.7% of participants use the sleep recording feature, only 50% are consistent users.

**Actionable Recommendations**

  1.	**Enhance Sleep Duration and Quality:** Implement bedtime reminders, relaxation content, and advice on minimizing screen time to help users achieve the recommended sleep duration.
  2.	**Increase Consistent Tracking:** Introduce charging reminders post-evening workout (7 PM) so the device is ready to wear to bed. Develop fast-charging devices and survey users on device comfort during sleep.

<br><br>

### Heart Rate Monitoring:

**Insight:** Only 42.4% of users utilized the heart rate feature, with an average bpm of 79.98, which is within the normal range. However, the lowest recorded heart rate was 36, which is below that of a well-trained athlete.

**Actionable Recommendations**

  1.	**Increase Usage:** Educate users on the benefits of heart rate monitoring and promote this feature more prominently through the physical activity tracking.
  2.	**Health Monitoring:** Provide personalized feedback and alerts for abnormal heart rates to encourage regular monitoring and improve health awareness.

<br><br>

### Weight:

**Insight:** The weight tracking feature is the most underutilized among users, with only 24.2% or 8 people using it.

**Actionable Recommendations**

1. **Product Addition and Integration:** Add a Bluetooth Smart Scale to the Bellabeat product catalog to offer a seamless weight tracking solution.
    - Currently, there are 10 million Bellabeat users worldwide. According to Fitabase data, 24.2% (8 people) track their weight. Weight can be tracked by manually entering data or using an Aria Smart Scale, which also tracks fat percentage. In this dataset, 2 people tracked their bodyfat (6.06% of users). Conservatively estimating that 6% of Bellabeat users (600,000) purchased a Bellabeat smart scale at the going price of [USD $49.95](https://www.fitbit.com/global/us/products/scales/aria-air), this could generate an additional $29.9 million in revenue.
    - As of 2022, [RRW](https://www.linkedin.com/pulse/global-smart-scale-market-share-2023-research-report-world-rrw/) reported that the global Smart Scale market was valued at USD $255M with a CAGR of 12.28%.

2. **Feature Visibility:** Enhance the visibility of the weight tracking feature in the app through onboarding tutorials, dashboard highlights, and periodic reminders.
3. **Incentives and Rewards:** Introduce gamified elements and rewards to encourage regular use of the weight tracking feature, such as badges, milestones, and discounts on related products.
<br><br>
<br><br>

# <span style="color: #FF8967;">Conclusion</span>

To drive business through marketing campaigns, leverage insights to enhance user engagement and health tracking features. Focus on promoting personalized physical activity and sleep plans, and integrate additional health monitoring tools. Emphasize the value of tailored content and motivational strategies to support users' health goals while balancing the frequency of reminders to avoid annoyance. Develop and highlight new products like a Bluetooth Smart Scale and emphasize user testimonials in campaigns. This strategic approach will increase user satisfaction and feature utilization, fostering a health-conscious user base and driving growth.
<br><br>
<br><br>
